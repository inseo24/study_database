# 6장 데이터베이스 객체 작성과 삭제

1. 데이터베이스 객체
    1. 데이터베이스 객체란 테이블이나 뷰, 인덱스 등 데이터베이스 내에 정의하는 모든 것을 일컫는 말이다. 
    2. 객체는 데이터베이스 내의 실체를 가지는 어떤 것이다.
    3. 객체 이름의 제약 사항(명명조건)
        1. 기존 이름이나 예약어와 중복하지 않는다.
        2. 숫자로 시작할 수 없다.
        3. 언더스코어(_) 이외의 기호는 사용할 수 없다.
        4. 한글을 사용할 때는 더블쿼트(MYSQL에선 백쿼트)로 둘러싼다.
        5. 시스템이 허용하는 길이를 초과하지 않는다.
        
2. 스키마
    1. 데이터베이스 객체는 스키마 안에 만들어진다. 객체 이름이 같아도 스키마가 서로 다르면 상관없다.
    2. 스키마 안에는 테이블을 정의할 수 있다. 이름이 충돌하지 않도록 기능하는 그릇을 네임스페이스라고 부른다.(스키마나 테이블은 네임스페이스이기도 하다.)
    
3. 테이블 변경
    
    
    ```sql
    -- 열 추가
    ALTER TABLE 테이블명 ADD 열 정의
    ALTER TABLE sample62 ADD newcol INTEGER;
    
    -- NOT NULL 제약이 걸린 열을 추가할 때는 기본값을 지정해야 한다.
    
    -- 열 속성 변경
    ALTER TABLE 테이블명 MODIFY 열 정의
    ALTER TABLE sample62 MODIFY newcol VARCHAR(20);
    
    -- 열 이름 변경
    ALTER TABLE 테이블명 CHANGE [기존 열 이름][신규 열 이름]
    ALTER TABLE sample62 CHANGE newcol c VARCHAR(20);
    
    -- 열 삭제 
    ALTER TABLE 테이블명 DROP 열명
    ALTER TABLE sample62 DROP c;
    
    -- 최대 길이 연장
    ALTER TABLE sample MODIFY col VARCHAR(30)
    -- 최대길이 줄이는 것은 에러 발생하기 쉬우니 되도록 하지 말자!
    
    -- 열 추가
    -- 이것도 확인 잘 하기!(테이블 정의가 바뀌므로 영향을 꽤 줌)
    ALTER TABLE sample ADD new_col INTEGER
    ```
    
4. 제약
    1. NOT NULL 제약
    2. 기본키 제약 - 중복값 저장 못함
    3. 복수 열로 기본키 제약 가능 - 해당 열들은 모두 NOT NULL이어야 함(체크함)
    4. 테이블 제약(CONSTRAINT), 열 제약 추가
    ```sql
    -- C열에 NOT NULL 제약 걸기
    ALTER TABLE sample631 MODIFY c VARCHAR(30) NOT NULL;

    -- 테이블 제약 추가
    -- 기본키 제약 추가
    ALTER TABLE sample631 ADD CONSTRAINT pkey_sample631 PRIMARY KEY(a);

    -- c열의 NOT NULL 제약 없애기
    ALTER TABLE sampel631 MODIFY c VARCHAR(30);

    -- 테이블 제약 삭제하기
    ALTER TABLE sample641 DROP CONSTRAINT pkey_sample631;

    -- 기본키 제약 삭제하기
    ALTER TABLE sample641 DROP PRIMARY KEY;
    ```




5. 인덱스 구조
    1. 데이터베이스 객체 중 하나
    2. 인덱스는 검색 속도 향상을 위해 붙여진 색인이다. 여기서 말하는 검색은 SELECT에, WHERE 조건을 지정해 일치하는 행을 찾는 과정이다. 
    3. 테이블에 인덱스가 지정되어 있으면 효율적으로 검색할 수 있어 WHERE 조건이 지정된 SELECT 명령의 처리 속도가 향상된다.
    4. 테이블과 별개로 독립된 데이터베이스 객체로 작성되나 테이블에 의존적인 객체이다. 
    5. 검색에 사용하는 알고리즘 
        1. BINARY TREE(이진 트리) - 이진 탐색에서 검색하기 쉬운 구조로 한 것
            1. 데이터가 미리 정렬되어 있어야 함
            2. 일반적으로 테이블은 인덱스를 작성하려면 테이블 데이터와 별개로 인덱스용 데이터가 저장장치에 만들어짐. 이 때 이진 트리라는 데이터 구조로 작성된다.(그게 루트 노드, 브랜치, 리프 노드 구조, 왼쪽은 작은 값, 오른 쪽은 큰 값)
            3. 이진 트리는 중복 값을 등록할 수 없다.
        2. 해시 
    6. 풀 테이블 스캔 : 인덱스가 지정되지 않은 테이블을 검색할 때 풀 테이블 스캔이라는 검색 방법을 사용한다. 테이블에 저장된 모든 값을 처음부터 차례로 조사해나가는 것이다. 
    7. 이진 탐색(BINARY SEARCH) : 차례로 나열된 집합에 대한 유효한 검색, 집합을 반으로 나눠 조사함, 대량 데이터를 검색할 때 풀보다 이진 탐색이 더 빠르다.
    

6. 인덱스 작성과 삭제
    
    ```sql
    CREATE INDEX isample65 ON sample62(no);
    // index가 a 칼럼에 대해 만들어지면 where 조건에 a 열이 안 쓰이면 그 인덱스도 못 씀
    DROP INDEX issample65 ON sample62;
    
    -- 인덱스 사용 여부 확인 가능
    EXPLAIN SELECT * FROM sample62 WHERE a = 'a';
    ```
    
    최적화  
    
    - select 실행 전 실행계획이 세워지는데 explain은 이 실행계획을 확인하는 명령이다.
    - 실행 계획에서는 인덱스의 유무 뿐만 아니라 인덱스 사용 여부에 대해서도 데이터베이스 내부의 최적화 처리를 통해 판단함, 이 때 판단기준으로 인덱스 품질도 고려함
    - 데이터 종류가 적을수록 인덱스 효율이 떨어짐, 반대로 다른 값으로 여러 종류의 데이터가 존재하면 효율이 좋아짐
    

7. 뷰 작성과 삭제
    - 뷰: SELECT 명령을 기록하는 데이터베이스 객체. 뷰를 작성해 복잡한 SELECT 명령을 간략히 표현할 수 있다.
    - 가상 테이블: 뷰는 테이블처럼 취급하나 실체가 존재하지 않는다는 의미에서 가상 테이블이라고도 함. 저장 공간을 가지지 않으므로 SELECT에서만 사용하는 것을 권장함
    
    ```sql
    CREATE VIEW sample_view_67 AS SELECT * FROM sample54; 
    SELECT * FROM sample_view_67;
    
    -- 열 지정해 뷰 작성
    CREATE VIEW sample_view_672(n, v, v2) AS
    	SELECT no, a, a*2 FROM sample54;
    SELECT * FROM sample_view_672 WHERE n=1;
    
    DROP VIEW sample_view_67;
    ```
    
    - 뷰는 데이터베이스 객체로 저장장치에 저장된다. 테이블과 달리 대량의 저장공간을 필요로 하는게 아니므로 데이터베이스에 저장되는 것은 SELECT 명령 뿐이다. 저장공간을 소비하지 않는 대신 CPU 자원을 사용한다.
    
    - SELECT 명령은 데이터베이스의 테이블에서 행을 검색해 클라이언트로 반환한다. ORDER BY, GROUP BY 역시 계산능력을 필요로 해 CPU를 사용한다.
    - 뷰를 참조하면 뷰에 등록된 SELECT 명령이 실행되고 실행 결과는 일시적으로 보존되며, 뷰를 참조할 때마다 SELECT 명령이 실행된다.
    
    - Materialized View
        - 뷰의 근원이 되는 테이블에 보관하는 데이터 양이 많거나 집계처리르 할 때도 뷰가 사용되면 처리 속도가 많이 떨어질 수 밖에 없음. 뷰를 중첩해 사용하는 경우도 속도가 떨어짐
        - 이를 회피하기 위해 사용하는게 머터리얼라이즈드 뷰다.
        - 일반적으로 뷰는 데이터를 일시적으로 저장했다가 쿼리를 실행할 때 함께 삭제되는 반면 머터리얼라이즈드 뷰는 데이터를 테이블처럼 저장장치에 저장해두고 사용한다.
        - 머터리얼라이즈드 뷰는 처음 참조됐을 때 데이터를 저장해두고 다시 참조할 때마다 이전에 저장한 데이터를 그대로 사용한다. 일반 뷰처럼 매번 select를 실행할 필요가 없다.
        - 다만 뷰에 지정된 테이블의 데이터가 변경된 경우에는 select 명령을 재실행해 데이터를 다시 저장한다.
        - 이처럼 변경 유무를 확인해 재실행하는 것은 rdbms가 자도응로 실행한다.
        - mysql 에서는 머티리얼라이즈드 뷰를 사용할 수 없다. oracle, db2에서만 사용할 수 있음
        
    - 함수 테이블
        - 뷰를 구성하는 select 명령은 단독으로 실행할 수 있어야 하나 부모 쿼리와 연관된 서브쿼리의 경우 뷰의 select 명령으로 사용할 수 없다.
        - 이를 회피하기 위해 사용하는 것이 함수 테이블이다.
        - 함수 테이블은 테이블의 결과값을 반환해주는 사용자정의 함수다. 함수에는 인수를 지정할 수 있기 때문에 인수의 값에 따라 where 조건을 붙여 결과값을 바꿀 수 있다. 그에 따라 상관 서브쿼리처럼 동작할 수 있다.